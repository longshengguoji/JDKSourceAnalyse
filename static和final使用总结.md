# final 、 static 使用总结
## 一、final
根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<br/>
final类不能被继承，没有子类，final类中的方法默认是final的。<br/>
final方法不能被子类的方法覆盖，但可以被继承。<br/>
final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br/>
final不能用于修饰构造方法。<br/>
注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。<br/>
1. final类
final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类的时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确认这个类不会再被扩展，那么就设计为final类。
2. final方法
如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。<br/>
使用final方法原因有二：<br/>
第一：把方法锁定，放置任何集成类修改它的意义和实现。
第二：高效。编译器在遇到调用final方法时会转入内嵌机制，大大提高执行效率。
3. final变量（常量）
用final修饰的成员变量表示常量，值一单给定就无法改变！
final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。
另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。
4. final参数
当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。

## 二、static
static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。<br/>
被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内找到他们。因此，static对象可以在它的任何对象创建之前访问，无序引用任何对象。<br/>
用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。<br/>
static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（也可以在非静态成员方法中使用），但是不能在其他类中通过类名来直接引用，这一点很重要。<br/>
static修饰的成员变量和成员方法习惯说称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：<br/>
类名.静态方法名（参数列表...）<br/>
类名.静态变量名<br/>
使用static修饰的代码块表示静态代码块，当Java虚拟机加载类时，就会执行该代码块。<br/>

1. static变量
按照是否静态的对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；另一种是没有被static修饰的变量，叫实例变量。两者的区别是：<br/>
对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。<br/>
对于实例变量，没创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。<br/>
2. 静态方法
3. static代码块

## 三、static和final一起使用的意义
static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br/>
对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br/>
对于方法，表示不可覆盖，并且可以通过类名直接访问。<br/>
特别要注意一个问题：<br/>
对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。
